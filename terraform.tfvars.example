# ============================================================================
# TERRAFORM KUBERNETES INFRASTRUCTURE - CONFIGURATION EXAMPLES
# ============================================================================
#
# This file provides comprehensive configuration examples for deploying
# a production-grade Kubernetes infrastructure stack supporting:
#
# - ARM64, AMD64, and mixed-architecture clusters
# - MicroK8s, K3s, EKS, GKE, AKS, and standard Kubernetes
# - Automatic architecture detection and intelligent service placement
# - NFS-CSI primary storage with hostPath fallback
# - Complete monitoring, security, and management stack
# - DNS provider-based certificate resolvers for flexible SSL management
#
# DNS PROVIDER CERTIFICATE RESOLVERS:
# The system now uses DNS provider names as certificate resolvers instead of
# hardcoded "wildcard". This provides better clarity and flexibility.
#
# Supported DNS providers:
# - hurricane (default) - Hurricane Electric DNS
# - cloudflare         - Cloudflare DNS
# - route53           - AWS Route53
# - digitalocean      - DigitalOcean DNS
# - gandi             - Gandi DNS
# - namecheap         - Namecheap DNS
# - godaddy           - GoDaddy DNS
# - ovh               - OVH DNS
# - linode            - Linode DNS
# - vultr             - Vultr DNS
# - hetzner           - Hetzner DNS
#
# Copy this file to terraform.tfvars and customize for your environment
# ============================================================================

# ============================================================================
# ALPHABETICALLY ORGANIZED CONFIGURATION
# ============================================================================

# Override authentication middleware for specific services
# Uses logical names: "basic", "ldap", "default"
auth_override = {
  prometheus   = "basic" # Use basic auth for Prometheus
  alertmanager = "basic" # Use basic auth for AlertManager
  # traefik dashboard will auto-use the highest priority enabled middleware
}

# Mixed Cluster Management
auto_mixed_cluster_mode = true

# Domain Structure: {workspace}.{platform}.{base_domain}
# Example: prod.k3s.example.com
base_domain = "example.com"     # Options: "local", "yourdomain.com"

# Override certificate resolvers for specific services
# By default, all services use the DNS provider name as their certificate resolver
# You can override specific services to use different resolvers

# cert_resolver_override = {
#   grafana      = "hurricane"    # Use Hurricane Electric for Grafana
#   prometheus   = "hurricane"    # Use Hurricane Electric for Prometheus
#   vault        = "default"      # Use HTTP challenge for Vault (no DNS required)
#   consul       = "hurricane"    # Use Hurricane Electric for Consul
#   portainer    = "hurricane"    # Use Hurricane Electric for Portainer
#   alertmanager = "hurricane"    # Use Hurricane Electric for AlertManager
# }

# CPU Architecture (leave empty for auto-detection)
cpu_arch = ""                  # Options: "", "amd64", "arm64"

# Per-service architecture overrides (advanced)
cpu_arch_override = {
  # Example: Force high-performance services on AMD64
  # prometheus = "amd64"
  # traefik    = "amd64"
  # grafana    = "arm64"   # UI services on efficient ARM64
}

# Resource Management
default_cpu_limit    = "500m"           # Per-container CPU limit
default_memory_limit = "512Mi"          # Per-container memory limit

# Helm Configuration
default_helm_cleanup_on_fail  = true      # Clean up failed deployments
default_helm_disable_webhooks = true      # Compatibility mode
default_helm_force_update     = true      # Force updates when needed
default_helm_replace          = true      # Allow resource updates/replacement
default_helm_timeout          = 600       # 10 minutes
default_helm_wait             = true      # Wait for deployments
default_helm_wait_for_jobs    = true      # Wait for jobs

# Auto-detect if empty
default_storage_class = ""

# Disable architecture scheduling (development/testing)
disable_arch_scheduling = {
  # Example: Allow services to run on any architecture
  # traefik = true
  # prometheus = true
}

# Debug output
enable_debug_outputs = false

# Enable MicroK8s mode with smaller resource footprint
enable_microk8s_mode = true

# Prevent resource exhaustion
enable_resource_limits = true

# Service Passwords (empty = auto-generate secure passwords)
grafana_admin_password = ""            # Grafana admin user

# Custom timeout values for specific Helm deployments (advanced users only)
helm_timeouts = {
  consul                 = 600 # 10 minutes - service mesh setup
  gatekeeper             = 300 # 5 minutes - policy engine
  grafana                = 600 # 10 minutes - dashboard setup + persistence
  host_path              = 180 # 3 minutes - storage driver
  loki                   = 300 # 5 minutes - log aggregation setup
  metallb                = 300 # 5 minutes - load balancer setup
  nfs_csi                = 300 # 5 minutes - storage driver setup
  node_feature_discovery = 180 # 3 minutes - node labeling
  portainer              = 300 # 5 minutes - container management UI
  prometheus_stack       = 900 # 15 minutes - complex monitoring stack
  prometheus_stack_crds  = 300 # 5 minutes - CRD installation
  promtail               = 180 # 3 minutes - log collection daemonset
  traefik                = 600 # 10 minutes - ingress controller needs time
  vault                  = 600 # 10 minutes - secrets management setup
}

# Let's Encrypt Configuration
le_email = "admin@example.com"    # Required for production SSL certificates

# MetalLB Load Balancer Configuration
metallb_address_pool = "192.168.1.200-192.168.1.210"

# STEP 2: Change enabled = false to enabled = true after first successful deployment
middleware_overrides = {
  # Master switch - change to true after first deployment
  enabled = false  # CHANGE TO TRUE after first deployment

  # Apply security to all services by default
  all = {
    enable_rate_limit   = true  # Protect against abuse
    enable_ip_whitelist = true  # Restrict to local networks
  }

  # Traefik dashboard - enable authentication
  traefik = {
    disable_auth = false  # Enable auth for dashboard
  }

  # Prometheus - enable basic auth + security
  prometheus = {
    disable_auth = false  # Enable auth for Prometheus
  }

  # AlertManager - enable basic auth + security
  alertmanager = {
    disable_auth = false  # Enable auth for AlertManager
  }

  # Services with built-in auth - security middlewares only
  grafana = {
    # No auth middleware needed (has built-in authentication)
  }

  portainer = {
    # No auth middleware needed (has built-in authentication)
  }

  consul = {
    # No auth middleware needed (has built-in authentication)
  }

  vault = {
    # No auth middleware needed (has built-in authentication)
  }
}

# Custom password for monitoring services (Prometheus/AlertManager) admin (empty = auto-generate)
monitoring_admin_password = ""

# NFS Configuration (when use_nfs_storage = true)
nfs_server_address = "192.168.1.100"      # NFS server IP
nfs_server_path    = "/mnt/nfs/k8s"        # NFS export path

# Platform identifier
platform_name = "k3s"            # Options: "k3s", "microk8s", "eks", "gke", "aks"

# Service passwords (empty = auto-generate secure passwords)
portainer_admin_password = ""            # Portainer admin user

# Service-specific configuration overrides for fine-grained control
service_overrides = {
  # Traefik Ingress Controller with DNS Provider Configuration
  traefik = {
    # Core settings
    cpu_arch           = ""                # Auto-detect
    chart_version      = ""                # Use default
    storage_class      = ""                # Auto-detect
    storage_size       = "1Gi"             # Certificate storage

    # Service configuration
    enable_dashboard   = false             # Disable for CI compatibility
    dashboard_password = ""                # Custom password
    cert_resolver      = "hurricane"       # Certificate resolver (DNS provider name)

    # DNS provider configuration - creates certificate resolver named after provider
    dns_providers = {
      primary = {
        name   = "hurricane"  # Creates "hurricane" certificate resolver
        config = {}           # Uses auto-generated tokens for Hurricane Electric
      }
      # Additional providers can be added here
      additional = []
    }

    # ALTERNATIVE DNS PROVIDER EXAMPLES:
    # Uncomment and configure one of the following to switch DNS providers
    #
    # # Cloudflare DNS Provider
    # dns_providers = {
    #   primary = {
    #     name = "cloudflare"
    #     config = {
    #       CF_API_EMAIL = "your-email@example.com"
    #       CF_API_KEY   = "your-global-api-key"
    #       # OR use DNS token (recommended)
    #       CF_DNS_API_TOKEN = "your-dns-api-token"
    #     }
    #   }
    # }
    #
    # # AWS Route53 DNS Provider
    # dns_providers = {
    #   primary = {
    #     name = "route53"
    #     config = {
    #       AWS_ACCESS_KEY_ID     = "your-access-key"
    #       AWS_SECRET_ACCESS_KEY = "your-secret-key"
    #       AWS_REGION           = "us-east-1"
    #     }
    #   }
    # }
    #
    # # DigitalOcean DNS Provider
    # dns_providers = {
    #   primary = {
    #     name = "digitalocean"
    #     config = {
    #       DO_AUTH_TOKEN = "your-digitalocean-api-token"
    #     }
    #   }
    # }

    # DNS challenge configuration
    dns_challenge_config = {
      resolvers                 = ["1.1.1.1:53", "8.8.8.8:53"]
      delay_before_check        = "150s"
      disable_propagation_check = false
      polling_interval          = "5s"
      propagation_timeout       = "300s"
      sequence_interval         = "60s"
      http_timeout              = "30s"
    }

    # Certificate resolvers configuration
    cert_resolvers = {
      # Default HTTP challenge resolver
      default = {
        challenge_type = "http"
      }
      # DNS challenge resolver using provider name
      hurricane = {
        challenge_type = "dns"
        dns_provider   = "hurricane"
      }
      # Custom resolvers can be added here
      custom = {}
    }

    # Resources (Improved defaults for better stability)
    cpu_limit          = "200m"           # Sufficient for production traffic
    memory_limit       = "256Mi"          # Enhanced memory for SSL/TLS processing
    cpu_request        = "100m"           # Higher baseline for consistent performance
    memory_request     = "128Mi"          # Better memory allocation

    # Middleware configuration - enabled by middleware_overrides.enabled flag
    middleware_config = {
      # Basic Authentication - ENABLED by default for great out-of-box experience
      basic_auth = {
        enabled         = true
        secret_name     = "monitoring-basic-auth"
        realm           = "Monitoring Services"
        static_password = "" # Auto-generated secure password
        username        = "admin"
      }

      # LDAP Authentication - DISABLED by default (enable if needed)
      ldap_auth = {
        enabled       = false
        method        = "forwardauth"  # Options: "forwardauth" (recommended) or "plugin"
        log_level     = "INFO"
        url           = "ldap://ldap.example.com"
        base_dn       = "ou=Users,dc=example,dc=com"
        attribute     = "uid"  # For JumpCloud, Active Directory uses "sAMAccountName"
        # bind_dn       = ""  # Optional: for authenticated bind
        # bind_password = ""  # Optional: for authenticated bind
        # search_filter = ""  # Optional: custom search filter like "(sAMAccountName={username})"
      }

      # Default Authentication - DISABLED by default
      default_auth = {
        enabled = false
        type    = "basic"
      }

      # Rate Limiting - ENABLED by default
      rate_limit = {
        enabled = true
        average = 100 # requests per second
        burst   = 200 # burst capacity
      }

      # IP Whitelist - ENABLED by default for security
      ip_whitelist = {
        enabled       = true
        source_ranges = ["192.168.0.0/16", "10.0.0.0/8", "172.16.0.0/12"] # Local networks
      }
    }

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true              # Wait for readiness
    helm_wait_for_jobs = false
  }

  # Prometheus Monitoring
  prometheus = {
    # Core settings
    cpu_arch           = ""                # Prefer AMD64 for performance
    storage_class      = ""                # Use shared storage if available
    storage_size       = "8Gi"             # Metrics storage

    # Service configuration
    enable_ingress     = true              # Enable ingress route
    retention_period   = "15d"             # Data retention

    # Resources
    cpu_limit          = "1000m"           # Higher for metrics processing
    memory_limit       = "2Gi"
    cpu_request        = "500m"
    memory_request     = "1Gi"

    # Helm deployment
    helm_timeout       = 900               # Longer timeout
    helm_wait          = true
    helm_wait_for_jobs = true
  }

  # Grafana Dashboards
  grafana = {
    # Core settings
    cpu_arch           = ""                # Auto-detect
    storage_class      = "hostpath"        # SQLite compatibility
    storage_size       = "2Gi"             # Dashboard storage

    # Service configuration
    enable_persistence = true              # Persistent dashboards
    node_name          = ""                # Pin to specific node
    admin_user         = "admin"
    admin_password     = ""                # Auto-generate

    # Resources
    cpu_limit          = "200m"
    memory_limit       = "256Mi"
    cpu_request        = "100m"
    memory_request     = "128Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # MetalLB Load Balancer
  metallb = {
    # Network configuration
    address_pool       = "192.168.1.200-192.168.1.210"

    # Resources (lightweight)
    cpu_limit          = "100m"
    memory_limit       = "64Mi"
    cpu_request        = "25m"
    memory_request     = "32Mi"

    # Helm deployment
    helm_timeout       = 300               # Quick deployment
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Vault Secrets Management
  vault = {
    # Core settings
    storage_class      = ""                # Shared storage recommended
    storage_size       = "1Gi"             # Secrets storage

    # Resources
    cpu_limit          = "500m"
    memory_limit       = "512Mi"
    cpu_request        = "250m"
    memory_request     = "256Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = true
  }

  # Consul Service Discovery
  consul = {
    # Core settings
    storage_class            = ""          # Shared storage recommended
    storage_size             = "1Gi"       # Service registry storage
    server_replicas          = 3          # HA configuration (3 servers recommended)
    client_replicas          = 0          # 0 = DaemonSet mode (one per node)
    enable_pod_anti_affinity = true       # Set false for small clusters (< 3 nodes)

    # Resources
    cpu_limit          = "500m"
    memory_limit       = "512Mi"
    cpu_request        = "250m"
    memory_request     = "256Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Portainer Container Management
  portainer = {
    # Core settings
    storage_class      = "hostpath"        # Local management data
    storage_size       = "1Gi"             # Management storage

    # Service configuration
    admin_password     = ""                # Auto-generate

    # Resources (lightweight UI)
    cpu_limit          = "200m"
    memory_limit       = "256Mi"
    cpu_request        = "50m"
    memory_request     = "128Mi"

    # Helm deployment
    helm_timeout       = 300
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Loki Log Aggregation
  loki = {
    # Core settings
    storage_class      = ""                # Use shared storage
    storage_size       = "5Gi"             # Log storage

    # Resources
    cpu_limit          = "500m"
    memory_limit       = "512Mi"
    cpu_request        = "100m"
    memory_request     = "256Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Kube-State-Metrics (Kubernetes Metrics Collection)
  kube_state_metrics = {
    # Core settings
    cpu_arch           = ""                # Auto-detect
    chart_version      = ""                # Use default

    # Resources (lightweight metrics collector)
    cpu_limit          = "100m"
    memory_limit       = "128Mi"
    cpu_request        = "50m"
    memory_request     = "64Mi"

    # Helm deployment
    helm_timeout       = 300
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Node-RED (Visual Programming for IoT)
  node_red = {
    # Core settings
    cpu_arch           = ""                # Auto-detect
    storage_class      = "hostpath"        # Local storage for flows
    storage_size       = "2Gi"             # Flow storage
    cert_resolver      = "hurricane"       # SSL certificates

    # Service configuration
    enable_persistence = true              # Persistent flows
    palette_packages   = [                 # Custom palette packages (npm packages or git repos)
      "node-red-contrib-home-assistant-websocket",
      "node-red-dashboard",
      "node-red-contrib-influxdb",
      "node-red-contrib-mqtt-broker",
      "node-red-node-pi-gpio",
      "node-red-contrib-modbus",
      # Git repository examples:
      # "https://github.com/user/custom-node-red-nodes.git",
      # "git+https://github.com/user/private-nodes.git",
      # "git+ssh://git@github.com/user/ssh-nodes.git"
    ]

    # Resources (moderate for automation)
    cpu_limit          = "500m"
    memory_limit       = "512Mi"
    cpu_request        = "250m"
    memory_request     = "256Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # n8n (Workflow Automation Platform)
  n8n = {
    # Core settings
    cpu_arch           = ""                # Auto-detect
    storage_class      = "hostpath"        # Local storage for workflows
    storage_size       = "5Gi"             # Workflow storage
    cert_resolver      = "hurricane"       # SSL certificates

    # Service configuration
    enable_persistence = true              # Persistent workflows
    enable_database    = false             # Use SQLite for simplicity

    # Resources (higher for workflow processing)
    cpu_limit          = "1000m"
    memory_limit       = "1Gi"
    cpu_request        = "500m"
    memory_request     = "512Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = false
  }
}

# SCENARIO 1: Raspberry Pi Homelab (Resource-Conscious)
services = {
  # Core infrastructure (essential)
  traefik                = true
  metallb                = true
  host_path              = true    # Local storage
  nfs_csi                = false   # Disable if no NFS

  # Lightweight monitoring
  prometheus             = true
  prometheus_crds        = true
  grafana                = true
  kube_state_metrics     = true    # Kubernetes metrics for Prometheus

  # Automation services (optional)
  node_red               = false   # Visual programming for IoT
  n8n                    = false   # Workflow automation

  # Optional services (disable for low resources)
  loki                  = false
  promtail              = false
  consul                = false
  vault                 = false
  gatekeeper            = false

  # Management and discovery
  portainer             = true
  node_feature_discovery = true
}

# SCENARIO 2: Production Mixed Cluster (Full Stack)
# services = {
#   # Complete infrastructure
#   traefik                = true
#   metallb                = true
#   nfs_csi                = true   # Shared storage
#   host_path              = true   # Fallback storage
#
#   # Full monitoring stack
#   prometheus             = true
#   prometheus_crds        = true
#   grafana                = true
#   kube_state_metrics     = true   # Kubernetes metrics
#   loki                   = true   # Log aggregation
#   promtail               = true   # Log collection
#
#   # Service mesh and security
#   consul                = true   # Service discovery
#   vault                 = true   # Secrets management
#   gatekeeper            = true   # Policy enforcement
#
#   # Management tools
#   portainer             = true
#   node_feature_discovery = true
# }

# SCENARIO 3: Cloud-Native Development (Cloud Provider)
# services = {
#   # Core (cloud load balancer available)
#   traefik                = true
#   metallb                = false  # Use cloud LB
#   nfs_csi                = false  # Use cloud storage
#   host_path              = false  # Use cloud storage
#
#   # Full monitoring for development
#   prometheus             = true
#   prometheus_crds        = true
#   grafana                = true
#   kube_state_metrics     = true
#   loki                   = true
#   promtail               = true
#
#   # Development security
#   consul                = true
#   vault                 = true
#   gatekeeper            = false  # Disable policies in dev
#
#   # Management
#   portainer             = true
#   node_feature_discovery = true
# }

# Override storage class for services (DEPRECATED: use service_overrides.{service}.storage_class)
storage_class_override = {
  # alertmanager = "hostpath"
  # consul       = "nfs-csi"
  # grafana      = "hostpath"
  # loki         = "hostpath"
  # portainer    = "nfs-csi"
  # prometheus   = "hostpath"
  # traefik      = "nfs-csi"
  # vault        = "nfs-csi"
}

# System-wide default values for consistent configuration
system_defaults = {
  # Network defaults
  nfs_server_address   = "192.168.1.100"
  nfs_server_path      = "/mnt/k8s-storage"
  metallb_address_pool = "192.168.1.200-192.168.1.210"

  # Resource defaults
  cpu_limit_default      = "200m"
  memory_limit_default   = "256Mi"
  cpu_request_default    = "100m"
  memory_request_default = "128Mi"

  # Resource defaults for high-performance services
  cpu_limit_high      = "1000m"
  memory_limit_high   = "2Gi"
  cpu_request_high    = "500m"
  memory_request_high = "1Gi"

  # Resource defaults for lightweight services
  cpu_limit_light      = "100m"
  memory_limit_light   = "64Mi"
  cpu_request_light    = "25m"
  memory_request_light = "32Mi"

  # Storage size defaults
  storage_size_small  = "1Gi"
  storage_size_medium = "2Gi"
  storage_size_large  = "4Gi"
  storage_size_xlarge = "8Gi"

  # MicroK8s optimized defaults
  microk8s_cpu_limit      = "200m"
  microk8s_memory_limit   = "256Mi"
  microk8s_storage_small  = "1Gi"
  microk8s_storage_medium = "2Gi"
  microk8s_storage_large  = "4Gi"

  # Helm timeout defaults
  helm_timeout_short  = 180
  helm_timeout_medium = 300
  helm_timeout_long   = 600
  helm_timeout_xllong = 900

  # Authentication defaults
  ldap_port_default  = 389
  rate_limit_average = 100
  rate_limit_burst   = 200

  # Service replica defaults
  ha_replicas_default = 2
  ha_replicas_high    = 3
}

# Default certificate resolver for Traefik SSL certificates
traefik_cert_resolver = "wildcard"

# Storage Backend Selection
use_hostpath_storage = true               # Enable for local storage
use_nfs_storage      = false              # Enable for shared storage

# ============================================================================
# EXAMPLE ENVIRONMENT CONFIGURATIONS
# ============================================================================

# Raspberry Pi 4 Cluster Example:
# base_domain = "local"
# platform_name = "k3s"
# cpu_arch = "arm64"
# use_nfs_storage = false
# use_hostpath_storage = true
# services.loki = false
# services.consul = false
# services.vault = false

# AMD64 Homelab Example:
# base_domain = "homelab.local"
# platform_name = "k3s"
# cpu_arch = "amd64"
# use_nfs_storage = true
# nfs_server_address = "192.168.1.100"
# Full services enabled

# Production Cloud Example:
# base_domain = "company.com"
# platform_name = "eks"
# cpu_arch = ""  # Auto-detect
# use_nfs_storage = false  # Use cloud storage
# le_email = "admin@company.com"
# All services enabled with production settings

# Mixed Architecture Example:
# auto_mixed_cluster_mode = true
# cpu_arch_override.traefik = "amd64"      # Performance critical
# cpu_arch_override.prometheus = "amd64"   # Resource intensive
# cpu_arch_override.grafana = "arm64"      # UI, less demanding

# DNS Provider Examples:
# Hurricane Electric (default):
# service_overrides.traefik.dns_providers.primary.name = "hurricane"
# service_overrides.traefik.dns_providers.primary.config = {}

# Cloudflare Example:
# service_overrides.traefik.dns_providers.primary.name = "cloudflare"
# service_overrides.traefik.dns_providers.primary.config = {
#   CF_API_EMAIL = "admin@example.com"
#   CF_API_KEY   = "your-global-api-key"
# }

# AWS Route53 Example:
# service_overrides.traefik.dns_providers.primary.name = "route53"
# service_overrides.traefik.dns_providers.primary.config = {
#   AWS_ACCESS_KEY_ID     = "your-access-key"
#   AWS_SECRET_ACCESS_KEY = "your-secret-key"
#   AWS_REGION           = "us-east-1"
# }
