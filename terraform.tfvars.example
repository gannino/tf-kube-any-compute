# ============================================================================
# TERRAFORM KUBERNETES INFRASTRUCTURE - CONFIGURATION EXAMPLES
# ============================================================================
#
# This file provides comprehensive configuration examples for deploying
# a production-grade Kubernetes infrastructure stack supporting:
#
# - ARM64, AMD64, and mixed-architecture clusters
# - MicroK8s, K3s, EKS, GKE, AKS, and standard Kubernetes
# - Automatic architecture detection and intelligent service placement
# - NFS-CSI primary storage with hostPath fallback
# - Complete monitoring, security, and management stack
# - DNS provider-based certificate resolvers for flexible SSL management
#
# DNS PROVIDER CERTIFICATE RESOLVERS:
# The system now uses DNS provider names as certificate resolvers instead of
# hardcoded "wildcard". This provides better clarity and flexibility.
#
# Supported DNS providers:
# - hurricane (default) - Hurricane Electric DNS
# - cloudflare         - Cloudflare DNS
# - route53           - AWS Route53
# - digitalocean      - DigitalOcean DNS
# - gandi             - Gandi DNS
# - namecheap         - Namecheap DNS
# - godaddy           - GoDaddy DNS
# - ovh               - OVH DNS
# - linode            - Linode DNS
# - vultr             - Vultr DNS
# - hetzner           - Hetzner DNS
#
# Copy this file to terraform.tfvars and customize for your environment
# ============================================================================

# ============================================================================
# DOMAIN CONFIGURATION - Modern Structure
# ============================================================================

# Domain Structure: {workspace}.{platform}.{base_domain}
# Example: prod.k3s.example.com
base_domain   = "example.com"     # Options: "local", "yourdomain.com"
platform_name = "k3s"            # Options: "k3s", "microk8s", "eks", "gke", "aks"

# Let's Encrypt Configuration
le_email = "admin@example.com"    # Required for production SSL certificates

# Certificate resolver - uses DNS provider name directly
# The system automatically creates certificate resolvers named after DNS providers
# traefik_cert_resolver = "hurricane"  # Automatically set from DNS provider configuration

# ============================================================================
# SECURITY & ACCESS CONFIGURATION
# ============================================================================

# Service Passwords (empty = auto-generate secure passwords)
grafana_admin_password     = ""            # Grafana admin user
portainer_admin_password   = ""            # Portainer admin user
monitoring_admin_password  = ""            # Prometheus/AlertManager basic auth

# ============================================================================
# MIDDLEWARE CONFIGURATION - AUTHENTICATION & SECURITY
# ============================================================================
#
# DEPLOYMENT STRATEGY:
# 1. First deployment: Basic services without authentication (CRDs not ready)
# 2. Second deployment: Enable authentication after Traefik CRDs are installed
#
# For FIRST deployment, keep middleware_overrides commented out.
# After successful first deployment, uncomment the middleware_overrides section below.
# ============================================================================

# STEP 2: Change enabled = false to enabled = true after first successful deployment
middleware_overrides = {
  # Master switch - change to true after first deployment
  enabled = false  # CHANGE TO TRUE after first deployment

  # Apply security to all services by default
  all = {
    enable_rate_limit   = true  # Protect against abuse
    enable_ip_whitelist = true  # Restrict to local networks
  }

  # Traefik dashboard - enable authentication
  traefik = {
    disable_auth = false  # Enable auth for dashboard
  }

  # Prometheus - enable basic auth + security
  prometheus = {
    disable_auth = false  # Enable auth for Prometheus
  }

  # AlertManager - enable basic auth + security
  alertmanager = {
    disable_auth = false  # Enable auth for AlertManager
  }

  # Services with built-in auth - security middlewares only
  grafana = {
    # No auth middleware needed (has built-in authentication)
  }

  portainer = {
    # No auth middleware needed (has built-in authentication)
  }

  consul = {
    # No auth middleware needed (has built-in authentication)
  }

  vault = {
    # No auth middleware needed (has built-in authentication)
  }
}

# ============================================================================
# ARCHITECTURE CONFIGURATION - Smart Detection
# ============================================================================

# CPU Architecture (leave empty for auto-detection)
cpu_arch = ""                  # Options: "", "amd64", "arm64"

# Mixed Cluster Management
auto_mixed_cluster_mode = true

# Per-service architecture overrides (advanced)
cpu_arch_override = {
  # Example: Force high-performance services on AMD64
  # prometheus = "amd64"
  # traefik    = "amd64"
  # grafana    = "arm64"   # UI services on efficient ARM64
}

# Disable architecture scheduling (development/testing)
disable_arch_scheduling = {
  # Example: Allow services to run on any architecture
  # traefik = true
  # prometheus = true
}

# ============================================================================
# SERVICE ENABLEMENT - Scenario-Based Configuration
# ============================================================================

# SCENARIO 1: Raspberry Pi Homelab (Resource-Conscious)
services = {
  # Core infrastructure (essential)
  traefik                = true
  metallb                = true
  host_path              = true    # Local storage
  nfs_csi                = false   # Disable if no NFS

  # Lightweight monitoring
  prometheus             = true
  prometheus_crds        = true
  grafana                = true
  kube_state_metrics     = true    # Kubernetes metrics for Prometheus

  # Optional services (disable for low resources)
  loki                  = false
  promtail              = false
  consul                = false
  vault                 = false
  gatekeeper            = false

  # Management and discovery
  portainer             = true
  node_feature_discovery = true
}

# SCENARIO 2: Production Mixed Cluster (Full Stack)
# services = {
#   # Complete infrastructure
#   traefik                = true
#   metallb                = true
#   nfs_csi                = true   # Shared storage
#   host_path              = true   # Fallback storage
#
#   # Full monitoring stack
#   prometheus             = true
#   prometheus_crds        = true
#   grafana                = true
#   kube_state_metrics     = true   # Kubernetes metrics
#   loki                   = true   # Log aggregation
#   promtail               = true   # Log collection
#
#   # Service mesh and security
#   consul                = true   # Service discovery
#   vault                 = true   # Secrets management
#   gatekeeper            = true   # Policy enforcement
#
#   # Management tools
#   portainer             = true
#   node_feature_discovery = true
# }

# SCENARIO 3: Cloud-Native Development (Cloud Provider)
# services = {
#   # Core (cloud load balancer available)
#   traefik                = true
#   metallb                = false  # Use cloud LB
#   nfs_csi                = false  # Use cloud storage
#   host_path              = false  # Use cloud storage
#
#   # Full monitoring for development
#   prometheus             = true
#   prometheus_crds        = true
#   grafana                = true
#   kube_state_metrics     = true
#   loki                   = true
#   promtail               = true
#
#   # Development security
#   consul                = true
#   vault                 = true
#   gatekeeper            = false  # Disable policies in dev
#
#   # Management
#   portainer             = true
#   node_feature_discovery = true
# }

# ============================================================================
# STORAGE CONFIGURATION - Flexible Strategy
# ============================================================================

# Storage Backend Selection
use_nfs_storage      = false              # Enable for shared storage
use_hostpath_storage = true               # Enable for local storage

# NFS Configuration (when use_nfs_storage = true)
nfs_server_address = "192.168.1.100"      # NFS server IP
nfs_server_path    = "/mnt/nfs/k8s"        # NFS export path

# Storage Class Override (optional)
default_storage_class = ""                # Auto-detect if empty

# ============================================================================
# NETWORKING CONFIGURATION
# ============================================================================

# MetalLB Load Balancer Configuration
metallb_address_pool = "192.168.1.200-192.168.1.210"

# ============================================================================
# PERFORMANCE & RESOURCE CONFIGURATION
# ============================================================================

# Resource Management
enable_resource_limits = true             # Prevent resource exhaustion
default_cpu_limit      = "500m"           # Per-container CPU limit
default_memory_limit   = "512Mi"          # Per-container memory limit

# Helm Configuration
default_helm_timeout          = 600       # 10 minutes
default_helm_disable_webhooks = true      # Compatibility mode
default_helm_wait             = true      # Wait for deployments
default_helm_wait_for_jobs    = true      # Wait for jobs

# ============================================================================
# SERVICE-SPECIFIC OVERRIDES - Advanced Configuration
# ============================================================================

service_overrides = {
  # Traefik Ingress Controller with DNS Provider Configuration
  traefik = {
    # Core settings
    cpu_arch           = ""                # Auto-detect
    chart_version      = ""                # Use default
    storage_class      = ""                # Auto-detect
    storage_size       = "1Gi"             # Certificate storage

    # Service configuration
    enable_dashboard   = false             # Disable for CI compatibility
    dashboard_password = ""                # Custom password
    cert_resolver      = "hurricane"       # Certificate resolver (DNS provider name)

    # DNS provider configuration - creates certificate resolver named after provider
    dns_providers = {
      primary = {
        name   = "hurricane"  # Creates "hurricane" certificate resolver
        config = {}           # Uses auto-generated tokens for Hurricane Electric
      }
      # Additional providers can be added here
      additional = []
    }

    # ALTERNATIVE DNS PROVIDER EXAMPLES:
    # Uncomment and configure one of the following to switch DNS providers
    #
    # # Cloudflare DNS Provider
    # dns_providers = {
    #   primary = {
    #     name = "cloudflare"
    #     config = {
    #       CF_API_EMAIL = "your-email@example.com"
    #       CF_API_KEY   = "your-global-api-key"
    #       # OR use DNS token (recommended)
    #       CF_DNS_API_TOKEN = "your-dns-api-token"
    #     }
    #   }
    # }
    #
    # # AWS Route53 DNS Provider
    # dns_providers = {
    #   primary = {
    #     name = "route53"
    #     config = {
    #       AWS_ACCESS_KEY_ID     = "your-access-key"
    #       AWS_SECRET_ACCESS_KEY = "your-secret-key"
    #       AWS_REGION           = "us-east-1"
    #     }
    #   }
    # }
    #
    # # DigitalOcean DNS Provider
    # dns_providers = {
    #   primary = {
    #     name = "digitalocean"
    #     config = {
    #       DO_AUTH_TOKEN = "your-digitalocean-api-token"
    #     }
    #   }
    # }

    # DNS challenge configuration
    dns_challenge_config = {
      resolvers                 = ["1.1.1.1:53", "8.8.8.8:53"]
      delay_before_check        = "150s"
      disable_propagation_check = false
      polling_interval          = "5s"
      propagation_timeout       = "300s"
      sequence_interval         = "60s"
      http_timeout              = "30s"
    }

    # Certificate resolvers configuration
    cert_resolvers = {
      # Default HTTP challenge resolver
      default = {
        challenge_type = "http"
      }
      # DNS challenge resolver using provider name
      hurricane = {
        challenge_type = "dns"
        dns_provider   = "hurricane"
      }
      # Custom resolvers can be added here
      custom = {}
    }

    # Resources (Improved defaults for better stability)
    cpu_limit          = "200m"           # Sufficient for production traffic
    memory_limit       = "256Mi"          # Enhanced memory for SSL/TLS processing
    cpu_request        = "100m"           # Higher baseline for consistent performance
    memory_request     = "128Mi"          # Better memory allocation

    # Middleware configuration - enabled by middleware_overrides.enabled flag
    middleware_config = {
      # Basic Authentication - ENABLED by default for great out-of-box experience
      basic_auth = {
        enabled         = true
        secret_name     = "monitoring-basic-auth"
        realm           = "Monitoring Services"
        static_password = "" # Auto-generated secure password
        username        = "admin"
      }

      # LDAP Authentication - DISABLED by default (enable if needed)
      ldap_auth = {
        enabled       = false
        method        = "forwardauth"  # Options: "forwardauth" (recommended) or "plugin"
        log_level     = "INFO"
        url           = "ldap://ldap.example.com"
        base_dn       = "ou=Users,dc=example,dc=com"
        attribute     = "uid"  # For JumpCloud, Active Directory uses "sAMAccountName"
        # bind_dn       = ""  # Optional: for authenticated bind
        # bind_password = ""  # Optional: for authenticated bind
        # search_filter = ""  # Optional: custom search filter like "(sAMAccountName={username})"
      }

      # Default Authentication - DISABLED by default
      default_auth = {
        enabled = false
        type    = "basic"
      }

      # Rate Limiting - ENABLED by default
      rate_limit = {
        enabled = true
        average = 100 # requests per second
        burst   = 200 # burst capacity
      }

      # IP Whitelist - ENABLED by default for security
      ip_whitelist = {
        enabled       = true
        source_ranges = ["192.168.0.0/16", "10.0.0.0/8", "172.16.0.0/12"] # Local networks
      }
    }

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true              # Wait for readiness
    helm_wait_for_jobs = false
  }

  # Prometheus Monitoring
  prometheus = {
    # Core settings
    cpu_arch           = ""                # Prefer AMD64 for performance
    storage_class      = ""                # Use shared storage if available
    storage_size       = "8Gi"             # Metrics storage

    # Service configuration
    enable_ingress     = true              # Enable ingress route
    retention_period   = "15d"             # Data retention

    # Resources
    cpu_limit          = "1000m"           # Higher for metrics processing
    memory_limit       = "2Gi"
    cpu_request        = "500m"
    memory_request     = "1Gi"

    # Helm deployment
    helm_timeout       = 900               # Longer timeout
    helm_wait          = true
    helm_wait_for_jobs = true
  }

  # Grafana Dashboards
  grafana = {
    # Core settings
    cpu_arch           = ""                # Auto-detect
    storage_class      = "hostpath"        # SQLite compatibility
    storage_size       = "2Gi"             # Dashboard storage

    # Service configuration
    enable_persistence = true              # Persistent dashboards
    node_name          = ""                # Pin to specific node
    admin_user         = "admin"
    admin_password     = ""                # Auto-generate

    # Resources
    cpu_limit          = "200m"
    memory_limit       = "256Mi"
    cpu_request        = "100m"
    memory_request     = "128Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # MetalLB Load Balancer
  metallb = {
    # Network configuration
    address_pool       = "192.168.1.200-192.168.1.210"

    # Resources (lightweight)
    cpu_limit          = "100m"
    memory_limit       = "64Mi"
    cpu_request        = "25m"
    memory_request     = "32Mi"

    # Helm deployment
    helm_timeout       = 300               # Quick deployment
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Vault Secrets Management
  vault = {
    # Core settings
    storage_class      = ""                # Shared storage recommended
    storage_size       = "1Gi"             # Secrets storage

    # Resources
    cpu_limit          = "500m"
    memory_limit       = "512Mi"
    cpu_request        = "250m"
    memory_request     = "256Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = true
  }

  # Consul Service Discovery
  consul = {
    # Core settings
    storage_class      = ""                # Shared storage recommended
    storage_size       = "1Gi"             # Service registry storage

    # Resources
    cpu_limit          = "500m"
    memory_limit       = "512Mi"
    cpu_request        = "250m"
    memory_request     = "256Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Portainer Container Management
  portainer = {
    # Core settings
    storage_class      = "hostpath"        # Local management data
    storage_size       = "1Gi"             # Management storage

    # Service configuration
    admin_password     = ""                # Auto-generate

    # Resources (lightweight UI)
    cpu_limit          = "200m"
    memory_limit       = "256Mi"
    cpu_request        = "50m"
    memory_request     = "128Mi"

    # Helm deployment
    helm_timeout       = 300
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Loki Log Aggregation
  loki = {
    # Core settings
    storage_class      = ""                # Use shared storage
    storage_size       = "5Gi"             # Log storage

    # Resources
    cpu_limit          = "500m"
    memory_limit       = "512Mi"
    cpu_request        = "100m"
    memory_request     = "256Mi"

    # Helm deployment
    helm_timeout       = 600
    helm_wait          = true
    helm_wait_for_jobs = false
  }

  # Kube-State-Metrics (Kubernetes Metrics Collection)
  kube_state_metrics = {
    # Core settings
    cpu_arch           = ""                # Auto-detect
    chart_version      = ""                # Use default

    # Resources (lightweight metrics collector)
    cpu_limit          = "100m"
    memory_limit       = "128Mi"
    cpu_request        = "50m"
    memory_request     = "64Mi"

    # Helm deployment
    helm_timeout       = 300
    helm_wait          = true
    helm_wait_for_jobs = false
  }
}

# ============================================================================
# EXAMPLE ENVIRONMENT CONFIGURATIONS
# ============================================================================

# Raspberry Pi 4 Cluster Example:
# base_domain = "local"
# platform_name = "k3s"
# cpu_arch = "arm64"
# use_nfs_storage = false
# use_hostpath_storage = true
# services.loki = false
# services.consul = false
# services.vault = false

# AMD64 Homelab Example:
# base_domain = "homelab.local"
# platform_name = "k3s"
# cpu_arch = "amd64"
# use_nfs_storage = true
# nfs_server_address = "192.168.1.100"
# Full services enabled

# Production Cloud Example:
# base_domain = "company.com"
# platform_name = "eks"
# cpu_arch = ""  # Auto-detect
# use_nfs_storage = false  # Use cloud storage
# le_email = "admin@company.com"
# All services enabled with production settings

# Mixed Architecture Example:
# auto_mixed_cluster_mode = true
# cpu_arch_override.traefik = "amd64"      # Performance critical
# cpu_arch_override.prometheus = "amd64"   # Resource intensive
# cpu_arch_override.grafana = "arm64"      # UI, less demanding

# DNS Provider Examples:
# Hurricane Electric (default):
# service_overrides.traefik.dns_providers.primary.name = "hurricane"
# service_overrides.traefik.dns_providers.primary.config = {}

# Cloudflare Example:
# service_overrides.traefik.dns_providers.primary.name = "cloudflare"
# service_overrides.traefik.dns_providers.primary.config = {
#   CF_API_EMAIL = "admin@example.com"
#   CF_API_KEY   = "your-global-api-key"
# }

# AWS Route53 Example:
# service_overrides.traefik.dns_providers.primary.name = "route53"
# service_overrides.traefik.dns_providers.primary.config = {
#   AWS_ACCESS_KEY_ID     = "your-access-key"
#   AWS_SECRET_ACCESS_KEY = "your-secret-key"
#   AWS_REGION           = "us-east-1"
# }

# ============================================================================
# CERTIFICATE RESOLVER OVERRIDES (Optional)
# ============================================================================

# Override certificate resolvers for specific services
# By default, all services use the DNS provider name as their certificate resolver
# You can override specific services to use different resolvers

# cert_resolver_override = {
#   grafana      = "hurricane"    # Use Hurricane Electric for Grafana
#   prometheus   = "hurricane"    # Use Hurricane Electric for Prometheus
#   vault        = "default"      # Use HTTP challenge for Vault (no DNS required)
#   consul       = "hurricane"    # Use Hurricane Electric for Consul
#   portainer    = "hurricane"    # Use Hurricane Electric for Portainer
#   alertmanager = "hurricane"    # Use Hurricane Electric for AlertManager
# }

# ============================================================================
# DEBUGGING
# ============================================================================

# Debug output
enable_debug_outputs = false
